<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Move基本类型 - Move 教程</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../0_introduction.html">简介</a></li><li class="chapter-item expanded "><a href="../1_hello_world/index.html"><strong aria-hidden="true">1.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../2_modules_and_scripts/index.html"><strong aria-hidden="true">2.</strong> 模块及脚本</a></li><li class="chapter-item expanded "><a href="../3_primitive_types/index.html" class="active"><strong aria-hidden="true">3.</strong> Move基本类型</a></li><li class="chapter-item expanded "><a href="../4_vector_and_string/index.html"><strong aria-hidden="true">4.</strong> 向量与字符串</a></li><li class="chapter-item expanded "><a href="../5_references/index.html"><strong aria-hidden="true">5.</strong> 引用</a></li><li class="chapter-item expanded "><a href="../6_constants/index.html"><strong aria-hidden="true">6.</strong> 常量</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move 教程</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="move-基础类型"><a class="header" href="#move-基础类型">Move 基础类型</a></h1>
<h2 id="概要"><a class="header" href="#概要">概要</a></h2>
<p>本节课我们会介绍一下 Move 中的基本类型，以及演示一些如何声明和使用的代码。 Move 语言的础类型有整型（Integers）、布尔型（Bool）、地址（Address)。Move没有浮点型（Float）和内建的字符串类型（String），但在 Move 的标准库中的 <code>string</code> 模块借助 u8 的向量实现了 <strong>String</strong> 类型。
我们这节课还会从 Address 延伸讲一下 Signer 。</p>
<p>我们首先通过新建一个 Move 项目，以便我们边讲边写:</p>
<pre><code class="language-shell">move new primitive_types
cd primitive_types
</code></pre>
<p>在 <code>Move.toml</code> 中添加我们需要的依赖，这里主要是我们后面可能需要用到 <code>std::debug::print()</code> 来查看一些结果：</p>
<pre><code class="language-toml">[dependencies]
MoveStdlib = { git = &quot;https://github.com/move-language/move.git&quot;, subdir = &quot;language/move-stdlib&quot;, rev = &quot;main&quot; }
MoveNursery = { git = &quot;https://github.com/move-language/move.git&quot;, subdir = &quot;language/move-stdlib/nursery&quot;, rev = &quot;main&quot; }
</code></pre>
<p>然后我们新建一个<code>scripts/</code> 目录，在这个目录下新建脚本文件 <code>my_script.move</code>，编写下面的代码，作为我们这节课程的“白板”：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script {
    use std::debug;

    fun main() {
        // Write the code here
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>当我们想运行一下 main 函数时，可以在命令行中执行如下指令</p>
<pre><code class="language-shell">move sandbox run scripts/my_script.move
</code></pre>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<h3 id="整型变量定义"><a class="header" href="#整型变量定义">整型变量定义</a></h3>
<p>Move中的整型目前只有3种，分别是<code>u8</code>、<code>u64</code>和<code>u128</code>，都是无符号整型。Move不支持有符号整型（Signed Integers），从目前来看未来也并没有引入有符号整型的计划，但后续应该会引入其他字节长度的无符号整型。</p>
<p>和其他语言的整型一样，占用字节长度决定了可以表示数值大小的范围：</p>
<table><thead><tr><th align="center">类型</th><th align="center">范围</th></tr></thead><tbody>
<tr><td align="center">u8</td><td align="center">0 ~ $2^8-1$</td></tr>
<tr><td align="center">u64</td><td align="center">0 ~ $2^{64}-1$</td></tr>
<tr><td align="center">u128</td><td align="center">0 ~ $2^{128}-1$</td></tr>
</tbody></table>
<p>我们可以有几种不同的方式来声明变量：<br />
1）先定义一个空的变量和类型，再设定它的值</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: u8;
v = 10; 
<span class="boring">}
</span></code></pre></pre>
<p>2）在定义变量和类型的同时设定值</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: u8 = 10;
<span class="boring">}
</span></code></pre></pre>
<p>3)我们也可以不用显式的写明变量的类型，编译器可以通过代码的上下文对变量的类型进行推断，当无法进行推断的时候，编译器默认会认为是<code>u64</code>类型</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = 10;
<span class="boring">}
</span></code></pre></pre>
<p>4）也可以将类型添加在字面值的后面</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = 10u64;
<span class="boring">}
</span></code></pre></pre>
<p>但如果字面值对于变量指定的(或编译器推断的)类型来说太大了，比如下面我们把 256 赋给一个 <code>u8</code> 类型的变量，而 <code>u8</code> 类型的范围是 0-255：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: u8 = 256;
<span class="boring">}
</span></code></pre></pre>
<p>编译器就会报错：</p>
<pre><code class="language-shell">error[E04021]: invalid number after type inference
  ┌─ ./sources/my_script.move:4:21
  │
4 │        let _v: u8 = 256;
  │                --   ^^^
  │                │    │
  │                │    Invalid numerical literal
  │                │    Annotating the literal might help inference: '256u64'
  │                Expected a literal of type 'u8', but the value is too large.
</code></pre>
<h3 id="整型变量运算"><a class="header" href="#整型变量运算">整型变量运算</a></h3>
<h4 id="数学运算"><a class="header" href="#数学运算">数学运算</a></h4>
<p>Move 中的整型都可以执行 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 运算，但符号两边变量的类型要求完全一致，也就是说 <code>u8</code> 只能和 <code>u8</code> 进行这些操作，<code>u8</code> 和 <code>u64</code> 就会报错，我们可以尝试一下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 10;
let b: u64 = 10;
a + b;
<span class="boring">}
</span></code></pre></pre>
<p>编译器会提示两个参数不相容</p>
<pre><code class="language-shell">error[E04007]: incompatible types
  ┌─ ./sources/my_script.move:6:11
  │
4 │         let a: u8 = 10;
  │                -- Found: 'u8'. It is not compatible with the other type.
5 │         let b: u64 = 10;
  │                --- Found: 'u64'. It is not compatible with the other type.
6 │         a + b;
  │           ^ Incompatible arguments to '+'
</code></pre>
<h4 id="按位运算"><a class="header" href="#按位运算">按位运算</a></h4>
<p>整型还支持按位运算 按位与<code>&amp;</code>、按位或<code>|</code>、按位亦或<code>^</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a:u8 = 10;      // 1010
let b:u8 = 9;       // 1001
let r_and = a &amp; b;  // 1000 -&gt; 8
let r_or = a | b;   // 1011 -&gt; 11
let r_xor = a ^ b;  // 0011 -&gt; 3

debug::print(&amp;r_and);
debug::print(&amp;r_or);
debug::print(&amp;r_xor);
<span class="boring">}
</span></code></pre></pre>
<p>同样，按位运算符两侧变量的类型也要求一致。</p>
<h4 id="位移运算"><a class="header" href="#位移运算">位移运算</a></h4>
<p>位移运算有两种，左位移 <code>&lt;&lt;</code> 和右位移 <code>&gt;&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 10;     // 1010
let b = a &lt;&lt; 1;     // 10100 -&gt; 20
let c = a &gt;&gt; 2;     // 10 -&gt; 2

debug::print(&amp;b);
debug::print(&amp;c);
<span class="boring">}
</span></code></pre></pre>
<p>这里不要求位移符号的两侧类型相等，但是右侧只能是 <code>u8</code> 类型，这也很容易理解， <code>u8</code> 最大是255，但目前 Move 最多只有 <code>u128</code>。</p>
<p>需要注意的是位移的位数不能<strong>超过或等于</strong>类型的字节数，也就是说 <code>u8</code>、<code>u64</code>、<code>u128</code> 分别最多只能位移 7、63、127 位：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 10;     // 1010
let b = a &lt;&lt; 8;     // Abort!
// Execution failed because of an arithmetic error (i.e., integer overflow/underflow, div/mod by zero, or invalid shift) in script at code offset 2
<span class="boring">}
</span></code></pre></pre>
<h4 id="对比运算"><a class="header" href="#对比运算">对比运算</a></h4>
<p>Move 中只有整型可以进行对比运算 <code>&lt;</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;=</code>，同样，符号两边的变量类型要一致</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 10;
let b: u8 = 11;

let c = a &gt; b;  // false
debug::print(&amp;c);

let c = a &lt; b;  // true
debug::print(&amp;c);

let c = a &gt;= b; // false
debug::print(&amp;c);

let c = a &lt;= b ; // true
debug::print(&amp;c);
<span class="boring">}
</span></code></pre></pre>
<h4 id="等号与不等号"><a class="header" href="#等号与不等号">等号与不等号</a></h4>
<p>虽然 Move 中只有整型可以进行对比运算，但是 <code>==</code> 和 <code>!=</code> 并不是整型独占的。不过不论如何，符号两侧的类型还是要求一致。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 10;
let b: u8 = 11;

let c = a == b;  // false
debug::print(&amp;c);

let c = a != b;  // true
debug::print(&amp;c);
<span class="boring">}
</span></code></pre></pre>
<p>关于相等性其他的一些知识点，会在学习 Move 语言后续的一些特性时讲到。</p>
<h4 id="类型映射"><a class="header" href="#类型映射">类型映射</a></h4>
<p>前面的运算基本要求符号两侧的变量类型一致，这样的限制可能会带来一些麻烦。因此 Move 提供了类型映射（casting），可以临时地转换类型，让符号两侧的变量可以执行运算。
只需要通过 <code>(e as T)</code> 的形式就可以实现类型的映射：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u8 = 10;
let b: u64 = 2;
let c = a + (b as u8); 

debug::print(&amp;c);
<span class="boring">}
</span></code></pre></pre>
<p>但需要注意的是，<strong>只有整型之间</strong>可以进行类型映射，并且变量的值不能超出目标类型的范围，例如 <code>256u64</code> 就无法转换成 <code>u8</code>, 程序会报错退出。</p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<p>布尔型的字面值只有 <code>true</code> 和 <code>false</code>。布尔型可以执行 逻辑与<code>&amp;&amp;</code>、逻辑或<code>||</code>、逻辑非<code>!</code> 的运算。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = true;
let b = true;
let c = false;
let r1 = a || b;        // true
let r2 = a || b &amp;&amp; c;   // true
let r3 = !a;            // false

debug::print(&amp;r1);
debug::print(&amp;r2);
debug::print(&amp;r3);
<span class="boring">}
</span></code></pre></pre>
<p>在一些语言中，整型在与布尔型运算时会自动进行转换，但在 Move 中是不可以的，尽管整型有类型映射，但类型映射只限制在不同字节长度的整型之间，因此 Move 的整型无法转化为布尔型。
也因此逻辑运算也只能在布尔型之间执行。</p>
<h2 id="address"><a class="header" href="#address">Address</a></h2>
<p>地址是 Move 中的一种类型，用于表示全局存储中的位置(或者称为帐户)，地址是一个 128bit 数值的标识符。</p>
<p>尽管是一个128位的整型，但 Move 并不允许通过整型来创建地址，也不允许地址进行任何的数学运算，也不允许改变地址，总的来说 Move 不允许地址发生动态的变化。</p>
<p>你可以在运行时通过地址的值来访问对应地址上的资源（Resources，这部分后面的章节会讲到），但不能在运行时通过来访问地址上的模块。
那么怎么来理解这句话呢，首先我们要看一下 Move 链的全局状态是怎么样的，官方提供了一张示意图：
<img src="https://github.com/move-language/move/raw/main/language/documentation/tutorial/diagrams/move_state.png" alt="" /></p>
<p>全局状态在 Rust 中的表示大致如下：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct GlobalStorage {
    resources: Map&lt;address, Map&lt;ResourceType, ResourceValue&gt;&gt;
    modules: Map&lt;address, Map&lt;ModuleName, ModuleBytecode&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>也就是说全局存储了两个 Map ，一个用来存每个地址有哪些资源，一个用来存每个地址有哪些模块。通过运行时只能访问第一个 Map 中的数据，也就是存储资源的那个 Map。</p>
<p>我们再介绍一下关于地址类型的语法，地址有两种类型：数值地址 和 命名地址。 任何有效的 u128 数值都可以用作地址的值。为了和整型区分，地址在使用的时候语法会根据上下文有所差异：</p>
<p>1）被用作表达式时，需要在地址的字面值或者命名标志符前加上 <code>@</code> 符号，这里的表达式也包括作为函数的参数等，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let addr_1 = @0xAB;
let addr_2 = @1234;
let addr_3 = @std; 
<span class="boring">}
</span></code></pre></pre>
<p>2）除此之外可以不用 <code>@</code> ，例如：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// import module
use 0x9::my_module;
// call function
std::debug::print(&amp;1);
<span class="boring">}
</span></code></pre></pre>
<p>命名地址需要我们在 Move.toml 中声明：</p>
<pre><code class="language-toml">[address]
std = &quot;0x1&quot;
addr = &quot;0xC0FFEECAFE&quot;
</code></pre>
<p>当编译的时候，编译器会把源码中的命名地址标识符转换成对应的字节码。
所以在编写源码时，一定要注意不要一会儿用命名地址，一会儿用它的数值地址，这会导致代码的可读性变差，并且从源码层面来说，两者并不相同，一个是编译时的参数，一个是常量。</p>
<h2 id="signer"><a class="header" href="#signer">Signer</a></h2>
<p>Signer 是 Move 内建的一种类型，不可以被复制，包含了交易发送者的地址信息。它代表了发送者的权利，也就是说它可以访问发送者地址下的资源。
可以把 Signer 看作是对地址类型的一种结构体封装：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct signer has drop { addr: address }
<span class="boring">}
</span></code></pre></pre>
<p>我们无法在代码中创建 Signer 类型的变量，只能通过给 Move 虚拟机传参来创建。 <code>Signer</code> 可以通过 <code>address_of</code> 来获取它内部地址的值。
有了 Signer 后，某些函数就可以验证交易发送者是否真的有权限来做这些事情，避免了弄虚作假。</p>
<h2 id="address--signer-演示"><a class="header" href="#address--signer-演示">Address &amp; Signer 演示</a></h2>
<p>然后我们简单的演示一下 <code>Address</code> 和 <code>Signer</code> 的使用，我们先在 <code>sources/</code> 下创建 <code>my_module.move</code> 文件：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>module 0x42::M {
    struct Coin has key, store{
        value: u64
    }

    public fun give_coin(account: &amp;signer) {
        let coin = Coin { value: 1 };   // Create a 'Coin' 
        move_to(account, coin);     // move the coin to account's address as a resource
    }

    public fun balance_of(owner: address): u64 acquires Coin {
        borrow_global&lt;Coin&gt;(owner).value    // query the value of the Coin at owner's address
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>这里我们简单的创建了一个 <code>Coin</code> 结构体，并提供了给某个地址一个 <code>Coin</code> 的方法 <code>give_coin</code>，以及检查某个地址上 <code>Coin</code> 的值的方法 <code>balance_of</code>。
这里可能涉及到一些特性和知识点，可以先不管他，只要知道这两个方法是做什么的就行了，后面的课程中会讲到这些点，这里只作简单的演示。</p>
<p>然后我们修改 <code>my_script.move</code>：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>script{
    use 0x1::debug;
    use std::signer;
    use 0x42::M;

    fun main(account: signer) {

        M::give_coin(&amp;account);

        let r = M::balance_of(signer::address_of(&amp;account));
        debug::print(&amp;r);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>脚本做的事情就是，先给 <strong>account</strong> 一个 <code>Coin</code>，然后我们再通过查看地址下 <code>Coin</code> 的 <code>value</code> 来确认是否执行成功了。</p>
<p>代码完成以后，我们把模块发布出去，并执行脚本，查看结果：</p>
<pre><code class="language-shell">move sandbox publish
move sandbox run scripts/my_script.move --signers 0xCD
</code></pre>
<p>这里的参数 <code>--signer 0xCD</code> 就是告诉 VM 我们的发送者地址是 <code>0xCD</code>。
我们可以看到打印的结果，输出 <code>1</code>，表明操作成功了：</p>
<pre><code class="language-shell">[debug] 1
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../2_modules_and_scripts/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../4_vector_and_string/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../2_modules_and_scripts/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../4_vector_and_string/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
